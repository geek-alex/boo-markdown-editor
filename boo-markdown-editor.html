<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../paper-styles/element-styles/paper-material-styles.html">
<link rel="import" href="../marked-element/marked-element.html">
<link rel="import" href="../iron-autogrow-textarea/iron-autogrow-textarea.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../boo-window/boo-window.html">

<dom-module id="boo-markdown-editor">
  <template>
    <style include="paper-material-styles">
      :host {
        display: block;
        position: relative;
      }
      .preview {
        display: block;
        background-color: white;
        @apply --shadow-elevation-16dp;
        @apply --preview;
        @apply --markdown-preview;
      }
      [slot="markdown-html"] {
        padding: 10px;
      }
      [slot="markdown-html"] img {
        max-width: 100%;
      }
      [slot="markdown-html"] video {
        max-width: 100%;
      }
      .toolbar {
        background-color: grey;
        position: fixed;
        border-radius: 2px;
        max-width: 80%;
        max-height: 100px;
        width: 0px;
        height: 0px;
        display: block;
        overflow: hidden;
        z-index: 1000000;
        white-space: nowrap;
      }
      .toolbar.opened {
        width: auto;
        height: auto;
        padding-left: 10px;
        padding-right: 10px;
        overflow: visible;
        @apply --shadow-elevation-2dp;
        @apply --markdown-toolbar;
      }

      .toolbar.opened::before {
        width: 0.625em;
        height: 0.625em;
        border-top: inherit;
        border-left: inherit;
        background: inherit;
        position: absolute;
        transform: rotate(45deg);
        top: -0.35em;
        left: 15px;
        display: inline-block;
        content: '';
      }
      iron-autogrow-textarea {
        border: none;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0);
      }
    </style>
    <iron-ajax 
      auto
      url=[[templateUrl]]
      handle-as="text"
      on-response="_templateRender"></iron-ajax>
    <div class="toolbar">
      <slot></slot>
    </div>
    <iron-autogrow-textarea 
      rows=[[rows]] 
      value={{content}}></iron-autogrow-textarea>
    <boo-window class="preview" width=[[previewWidth]] height=[[previewHeight]]>
      <section slot="header">
        <marked-element markdown=[[content]]>
          <div slot="markdown-html"></div>
        </marked-element>
      </section>
    </boo-window>
  </template>

  <script>

    /**
     * `boo-markdown-editor`
     * a markdown editor
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class BooMarkdownEditor extends Polymer.Element {

      static get is() { return 'boo-markdown-editor'; }

      static get properties() {
        return {
          content: {
            type: String,
            reflectToAttribute: true,
            notify: true
          },
          editor: {
            type: Object,
          },
          templateUrl: {
            type: String,
            reflectToAttribute: true
          },
          showToolbar: {
            type: Boolean,
            value: false,
            notify: true,
            observer: '_showToolbarChanged'
          },
          toolbarX: {
            type: Number,
          },
          toolbarY: {
            type: Number,
          },
          preview: {
            type: Boolean,
            reflectToAttribute: true,
            notify: true
          },
          previewWidth: {
            type: Number,
            value: 400
          },
          previewHeight: {
            type: Number,
            value: 300
          },
          _toolbarWidth: {
            type: Number,
          },
          _toolbarHeight: {
            type: Number,
          },
          rows: {
            type: Number,
            reflectToAttribute: true,
            value: 5
          }
        };
      }

      connectedCallback() {
        super.connectedCallback();
        let _this = this;
        window.addEventListener('resize', e => {
          _this._initPreview();
          _this._initContextMenu();
        });
        this._initPreview();
        this._initContextMenu();
        this.editor = this.shadowRoot
          .querySelector('iron-autogrow-textarea')
          .shadowRoot.querySelector('#textarea');
      }

      insert(text) {
        this.editor.focus();
        if (document.queryCommandSupported('insertText')) {
          document.execCommand('insertText', false, text);
          return this;
        }
        throw '该浏览器不支持该markdown';
      }

      insertAt(text, start, end)
      {
        if (arguments.length == 2) {
          end = start;
        }
        this.select(start, end);
        let _this = this;
        _this.insert(text);
      }

      select(start, end) {
        let editor = this.editor;
        if (arguments.length == 1) {
          end = start;
        }
        if ("selectionStart" in editor) {
          editor.selectionStart = start;
          editor.selectionEnd = end;
          return this;;
        }
        if (editor.createTextRange) {
          var rng = editor.createTextRange();
          rng.moveStart("character", start);
          rng.collapse();
          rng.moveEnd("character", end - start);
          rng.select();
        }
        return this;
      }

      /**
       * 返回当前选区的开始和结束
       */
      _getRange(inputElem) {
        var start = 0, end = 0, normalizedValue, range,
            textInputRange, len, endRange;

        if (typeof inputElem.selectionStart == "number" && 
                              typeof inputElem.selectionEnd == "number") {
          return {
            start: inputElem.selectionStart,
            end: inputElem.selectionEnd,
          };
        }
        range = document.selection.createRange();
        if (range && range.parentElement() == inputElem) {
          len = inputElem.value.length;
          normalizedValue = inputElem.value.replace(/\r\n/g, "\n");

          // Create a working TextRange that lives only in the input
          textInputRange = inputElem.createTextRange();
          textInputRange.moveToBookmark(range.getBookmark());

          // Check if the start and end of the selection are at the very end
          // of the input, since moveStart/moveEnd doesn't return what we want
          // in those cases
          endRange = inputElem.createTextRange();
          endRange.collapse(false);

          if (textInputRange.compareEndPoints("StartToEnd", endRange) > -1) {
            return {
              start: len,
              end: len
            };
          }
          start = -textInputRange.moveStart("character", -len);
          start += normalizedValue.slice(0, start).split("\n").length - 1;

          if (textInputRange.compareEndPoints("EndToEnd", endRange) > -1) {
            return {
              start: start,
              end: len
            };
          }
          end = -textInputRange.moveEnd("character", -len);
          end += normalizedValue.slice(0, end).split("\n").length - 1;
        }
        return {
            start: start,
            end: end
        };
      }

      _showToolbarChanged(showToolbar, old) {
        let toolbar = this.shadowRoot.querySelector('.toolbar');
        let _this = this;
        if (showToolbar) {
          toolbar.style.left = _this.toolbarX + 'px';
          toolbar.style.top = _this.toolbarY + 'px';
          let ani = toolbar.animate([{
            opacity: 0,
            width: '0px',
            height: '0px',
            transform: 'translateY(-5px)'
          }, {
            opacity: 1,
            width: _this._toolbarWidth + 'px',
            height: _this._toolbarHeight + 'px',
            transform: 'translateY(0px)'
          }], 200);
          ani.onfinish = () => {
            let rect = toolbar.getBoundingClientRect();
            _this._addClass(toolbar, 'opened');
            _this.dispatchEvent(new CustomEvent('toolbar-opened'));
          }
          ani.play();
          return;
        }
        let rect = toolbar.getBoundingClientRect();
        this._toolbarWidth = rect.width;
        this._toolbarHeight = rect.height;
        if (old == undefined) {
          _this._removeClass(toolbar, 'opened');
          _this.dispatchEvent(new CustomEvent('toolbar-closed'));
          return;
        }
        new Promise((resolved, reject) => {
          let ani = toolbar.animate([{
            opacity: 1,
            width: _this._toolbarWidth + 'px',
            height: _this._toolbarHeight + 'px',
            transform: 'translateY(0px)'
          }, {
            opacity: 0,
            width: '0px',
            height: '0px',
            transform: 'translateY(-10px)'
          }], 50);
          ani.pause();
          ani.onfinish = e => {
            resolved();
          }
          ani.play();
        }).then(() => {
          _this._removeClass(toolbar, 'opened');
          _this.dispatchEvent(new CustomEvent('toolbar-closed'));
        });
      }

      _templateRender(e) {
        this.content = e.detail.response;
      }

      _initContextMenu() {
        let _this = this;
        let editor = this.shadowRoot.querySelector('iron-autogrow-textarea');
        editor.addEventListener('contextmenu', e => {
          let contextmenu = false;
          for(let i in _this.childNodes) {
            if (_this.childNodes[i].tagName != undefined) {
              contextmenu = true;
              break;
            }
          }
          if (!contextmenu) {
            return;
          }
          let rect = editor.getBoundingClientRect();
          _this.toolbarX = e.clientX - 20;
          _this.toolbarY = e.clientY + 20;
          _this.showToolbar = true;
          e.preventDefault();
        });
        editor.addEventListener('click', e => {
          _this.showToolbar = false;
        });
      }

      _initPreview() {
        let booWindow = this.shadowRoot.querySelector('boo-window');
        let pos = booWindow.bottomRight();
        booWindow.x = pos.x - 20;
        booWindow.y = pos.y - 20;
      }

      _getWindowSize () {
        var result = {};
        if (document.documentElement.clientWidth) {
          result.width = document.documentElement.clientWidth;
        } else {
          result.width = document.body.clientWidth;
        }
        if (document.documentElement.clientHeight) {
          result.height = document.documentElement.clientHeight;
        } else {
          result.height = document.body.clientHeight;
        }
        return result;
      }

      _addClass(node, klass) {

        let klasses = node.getAttribute('class').split(' ');
        klasses.push(klass);
        node.setAttribute('class', klasses.join(' '));
      }

      _removeClass(node, klass) {

        let klasses = node.getAttribute('class').split(' ');
        let index = klasses.indexOf(klass);
        if (index == -1) {
          return; 
        }
        klasses.splice(index, 1);
        node.setAttribute('class', klasses.join(' '));
      }
    }

    window.customElements.define(BooMarkdownEditor.is, BooMarkdownEditor);
  </script>
</dom-module>
